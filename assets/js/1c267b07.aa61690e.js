"use strict";(self.webpackChunkfnts_docs=self.webpackChunkfnts_docs||[]).push([[426],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return f}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=o.createContext({}),c=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=c(e.components);return o.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,l=a(e,["components","mdxType","originalType","parentName"]),m=c(n),f=r,d=m["".concat(p,".").concat(f)]||m[f]||u[f]||i;return n?o.createElement(d,s(s({ref:t},l),{},{components:n})):o.createElement(d,s({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=m;var a={};for(var p in t)hasOwnProperty.call(t,p)&&(a[p]=t[p]);a.originalType=e,a.mdxType="string"==typeof e?e:r,s[1]=a;for(var c=2;c<i;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7337:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return a},contentTitle:function(){return p},metadata:function(){return c},toc:function(){return l},default:function(){return m}});var o=n(7462),r=n(3366),i=(n(7294),n(3905)),s=["components"],a={id:"composition",slug:"/concepts/composition",title:"Composition"},p=void 0,c={unversionedId:"concepts/composition",id:"concepts/composition",isDocsHomePage:!1,title:"Composition",description:"Composition in fnts is represented through the compose and pipe functions.",source:"@site/docs/concepts/composition.md",sourceDirName:"concepts",slug:"/concepts/composition",permalink:"/fnts/concepts/composition",editUrl:"https://github.com/drizzer14/fnts/docs/docs/concepts/composition.md",tags:[],version:"current",frontMatter:{id:"composition",slug:"/concepts/composition",title:"Composition"},sidebar:"default",previous:{title:"Arguments Permutation",permalink:"/fnts/concepts/arguments-permutation"},next:{title:"Currying",permalink:"/fnts/concepts/currying"}},l=[],u={toc:l};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Composition in ",(0,i.kt)("inlineCode",{parentName:"p"},"fnts")," is represented through the ",(0,i.kt)("inlineCode",{parentName:"p"},"compose")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pipe")," functions.\nBoth are implemented without the overloads, which causes the types to be\nrather ",(0,i.kt)("em",{parentName:"p"},"imposed")," than inferred."),(0,i.kt)("p",null,"Commonly, as well as in ",(0,i.kt)("inlineCode",{parentName:"p"},"fnts"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"compose")," is used to apply a list of functions\nto an argument, passing the result of each application to the next one in a ",(0,i.kt)("strong",{parentName:"p"},"\nright to left")," order:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import compose from 'fnts/compose';\n\nconst isTwoDigits = compose(\n  (b: boolean) => b ? 'true' : 'false',\n  (s: string) => s.length === 2, // argument type imposed from the next function\n  (n: number) => `${n}`,\n); // will accept only a number as argument\n\nisTwoDigits(5) === 'false';\nisTwoDigits(14) === 'true';\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"pipe"),", on the other hand, is executed in a more familiar ",(0,i.kt)("strong",{parentName:"p"},"left to right"),"\norder:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import pipe from 'fnts/pipe';\n\nconst isTwoDigits = pipe(\n  (n: number) => `${n}`,\n  (s: string) => s.length === 2,\n  (b: boolean) => b ? 'true' : 'false',\n);\n\nisTwoDigits(5) === 'false';\nisTwoDigits(14) === 'true';\n")),(0,i.kt)("p",null,"Both ",(0,i.kt)("inlineCode",{parentName:"p"},"compose")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pipe")," allow for their first to-be-executed function to\nhave multiple arguments."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import compose from 'fnts/compose';\n\nconst isEvenSum = compose(\n  (b: boolean) => b ? 'true' : 'false',\n  (s: number) => s % 2 === 0,\n  (a: number, b: number) => a + b,\n);\n\nisEvenSum(2, 2) === 'true';\nisEvenSum(17, 32) === 'false';\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"An important thing to note here, once again, is that there are no overloads\npresent, so make to sure to have your functions properly typed and placed in a\nright order. Otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"compose")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pipe")," will emit TypeScript errors\nsuggesting you to correct their types."),(0,i.kt)("p",null,"But fear not, as both use the same determination algorithm for types as you'd\nexpect: the return type of the previous function is the same as the argument\ntype of the next one."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"One big downside to this, is that it is not always reliable with generic\nfunctions. For example (taken from\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/drizzer14/fnts/issues/16"},"issue")," on GitHub):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import compose from 'fnts/compose';\n\ndeclare const as: number[];\n\nconst cs = compose(\n  (b) => b.toString(),\n  (x) => x > 0\n)(as);\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"compose")," here actually does not know anything about the types of ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," and the\nfunctions' arguments it was provided. To fix this we need to manually annotate\nthe arguments which \"fixes\" the problem, although I don't think it's necessarily\na good way to use the library and TypeScript in general."),(0,i.kt)("p",null,"The issue above comes from\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/microsoft/TypeScript/issues/30369"},"language itself")," and\nat this moment in time cannot be fixed by the library."))}m.isMDXComponent=!0}}]);