"use strict";(self.webpackChunkfnts_docs=self.webpackChunkfnts_docs||[]).push([[754],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=r.createContext({}),l=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(t),m=o,f=u["".concat(p,".").concat(m)]||u[m]||d[m]||a;return t?r.createElement(f,i(i({ref:n},c),{},{components:t})):r.createElement(f,i({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=u;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},7298:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=t(7462),o=(t(7294),t(3905));const a={id:"migrating-to-v2",slug:"/migrating-to-v2",title:"Migrating to v2",sidebar_position:2},i=void 0,s={unversionedId:"migrating-to-v2",id:"migrating-to-v2",title:"Migrating to v2",description:"After extensive use of fnts in real codebases, several problems and",source:"@site/docs/migrating-to-v2.md",sourceDirName:".",slug:"/migrating-to-v2",permalink:"/fnts/migrating-to-v2",draft:!1,editUrl:"https://github.com/drizzer14/fnts/docs/docs/migrating-to-v2.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"migrating-to-v2",slug:"/migrating-to-v2",title:"Migrating to v2",sidebar_position:2},sidebar:"default",previous:{title:"Side Effects",permalink:"/fnts/concepts/side-effects"},next:{title:"Migrating to v3",permalink:"/fnts/migrating-to-v3"}},p={},l=[{value:"Version increment",id:"version-increment",level:2},{value:"TypeScript version bump",id:"typescript-version-bump",level:2},{value:"API changes",id:"api-changes",level:2}],c={toc:l};function d(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"After extensive use of ",(0,o.kt)("inlineCode",{parentName:"p"},"fnts")," in real codebases, several problems and\ninconsistencies emerged. Version 2.0.0 of the library is dedicated to fixing\nthese problems and introducing more consistent approaches for use of its\nmodules."),(0,o.kt)("h2",{id:"version-increment"},"Version increment"),(0,o.kt)("p",null,"One important thing to understand here is that the new major version introduces\nalmost no drastic API changes. However, semantic versioning requires for any\nAPI change that is not backward compatible to bump the package version to a\nmajor, and so I did."),(0,o.kt)("h2",{id:"typescript-version-bump"},"TypeScript version bump"),(0,o.kt)("p",null,"Make sure to use ",(0,o.kt)("inlineCode",{parentName:"p"},"fnts@2")," with TypeScript upgraded to at least 4.7 minor\nversion. 4.2.2 support is dropped from now on."),(0,o.kt)("h2",{id:"api-changes"},"API changes"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"compose")," and ",(0,o.kt)("inlineCode",{parentName:"strong"},"pipe")," now accept only two functions at a time")," "),(0,o.kt)("p",null,"Variadic composition proved itself non-sustainable with types being inferred\nwrongly or not being inferred at all, causing the developer to write such\na composition without the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"compose")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"pipe")," or trying to manually\nannotate composed functions in place, which resulted in more clutter and\ncode that without ",(0,o.kt)("inlineCode",{parentName:"p"},"compose")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"pipe")," at all."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"// before\n\ncompose(f, g, h, k)(...args)\n\npipe(k, h, g, f)(...args)\n\n// after\n\ncompose(\n  compose(f, g),\n  compose(h, k)\n)(...args)\n\npipe(\n  pipe(k, h),\n  pipe(g, f)\n)(...args)\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Monad operators' interfaces are more straightforward now")),(0,o.kt)("p",null,"Attempts to guess input and output types of monad operators were reduced to\njust accepting generic monad constructors (",(0,o.kt)("inlineCode",{parentName:"p"},"Maybe")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Either"),") and\nreturning generic results (",(0,o.kt)("inlineCode",{parentName:"p"},"Monad")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Either"),") instead of relying on\nconcrete types (",(0,o.kt)("inlineCode",{parentName:"p"},"Just"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Nothing"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Left"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Right"),") which in most cases\ncould not be obtained within real use-cases."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"// before\n\ntype Fold<Monad extends Maybe<any>> =\n  Monad extends Just<infer Value>\n    ? Value\n    : Monad extends Nothing\n      ? undefined\n      : never\n\nfunction fold<Monad extends Maybe<any>> (\n  monad: Monad\n): Fold<Monad>\n\n// after\n\ntype Fold<Monad extends Maybe<any>> =\n  Monad extends Just<infer Value>\n    ? Value\n    : Monad extends Nothing\n      ? undefined\n      : Monad extends Maybe<infer Value>\n        ? Value | undefined\n        : never\n\nfunction fold<Monad extends Just<any>> (\n  monad: Monad\n): Fold<Monad>\n\nfunction fold<Value> (\n  monad: Maybe<Value>\n): Value | undefined\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"ternary")," function got rekt")),(0,o.kt)("p",null,"Syntactic ternary operator ",(0,o.kt)("inlineCode",{parentName:"p"},"? :")," provides more confidence and type safety\nthan its functional counterpart, which, to me, has two major flaws:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"No support for type guards."),(0,o.kt)("li",{parentName:"ol"},"Weak parameter inference.")),(0,o.kt)("p",null,"This was enough to decide to remove it from the library entirely, since it\nbrought no convenience, but rather problems and unsafety."),(0,o.kt)("hr",null),(0,o.kt)("p",null,"And that's it!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"npm i fnts@latest\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"yarn add fnts@latest\n")))}d.isMDXComponent=!0}}]);