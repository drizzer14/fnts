"use strict";(self.webpackChunkfnts_docs=self.webpackChunkfnts_docs||[]).push([[372],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(n),d=a,f=u["".concat(p,".").concat(d)]||u[d]||m[d]||o;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6777:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const o={id:"overview",slug:"/",title:"Overview",sidebar_position:0},i=void 0,s={unversionedId:"overview",id:"overview",title:"Overview",description:'fnts is an abbreviation for something like a "functional TypeScript". You could see a similar concept in libraries like fp-ts or ramda, each endorsing their own implementation of the idea.',source:"@site/docs/overview.md",sourceDirName:".",slug:"/",permalink:"/fnts/",draft:!1,editUrl:"https://github.com/drizzer14/fnts/docs/docs/overview.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{id:"overview",slug:"/",title:"Overview",sidebar_position:0},sidebar:"default",next:{title:"Installation and Usage",permalink:"/fnts/installation-and-usage"}},p={},l=[{value:"Tooling",id:"tooling",level:2},{value:"Monads",id:"monads",level:3},{value:"Composition",id:"composition",level:3},{value:"Currying",id:"currying",level:3},{value:"Application",id:"application",level:3},{value:"Arguments Permutation",id:"arguments-permutation",level:3},{value:"Side effects",id:"side-effects",level:3},{value:"Guarding",id:"guarding",level:3},{value:"Lensing (-ish?)",id:"lensing--ish",level:3}],c={toc:l};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"fnts"),' is an abbreviation for something like a "functional TypeScript". You could see a similar concept in libraries like ',(0,a.kt)("a",{parentName:"p",href:"https://github.com/gcanti/fp-ts"},"fp-ts")," or ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ramda/ramda"},"ramda"),", each endorsing their own implementation of the idea."),(0,a.kt)("p",null,"Here, the philosophy is to give the small set of functions, the possession of which makes it easier to operate the code in a functional style."),(0,a.kt)("p",null,'The minimal amount of abstractions not present in the TypeScript itself, or being hard to implement and use, (like HKT, typeclasses, overwhelming amount of iterators and transducers) aims to reduce the learning curve of this seemingly "different" style of programming.'),(0,a.kt)("h2",{id:"tooling"},"Tooling"),(0,a.kt)("p",null,"The library basically provides the tools to handily operate the following concepts: monads, currying, composition, guarding, handling side effects and control flows. Nothing more, nothing less."),(0,a.kt)("h3",{id:"monads"},(0,a.kt)("a",{parentName:"h3",href:"/concepts/monads"},"Monads")),(0,a.kt)("p",null,"Out of the variety of monads ",(0,a.kt)("inlineCode",{parentName:"p"},"fnts")," chooses two presumably most suitable ones: ",(0,a.kt)("inlineCode",{parentName:"p"},"maybe")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"either"),". Each have their own constructors and operators (as opposed to classes and methods based approach seen commonly)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import maybe from 'fnts/maybe';\nimport { foldMap } from 'fnts/maybe/operators';\n\nfoldMap(\n  maybe([1, 2, 3].find((n) => n > 2)),\n  (n) => n === 3\n); // true\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import either from 'fnts/either';\nimport { bifoldMap } from 'fnts/either/operators';\n\nbifoldMap(\n  await either(\n    () => fetch('https://github.com')\n  ),\n  (error) => console.error(error),\n  (data) => data\n)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import eitherSync from 'fnts/either';\nimport { bifoldMap } from 'fnts/either/operators';\n\nbifoldMap(\n  eitherSync(\n   () => JSON.parse(localStorage.getItem('context'))\n  ),\n  (error) => console.error(error),\n  (data) => data\n);\n")),(0,a.kt)("h3",{id:"composition"},(0,a.kt)("a",{parentName:"h3",href:"/concepts/composition"},"Composition")),(0,a.kt)("p",null,"Composition in ",(0,a.kt)("inlineCode",{parentName:"p"},"fnts")," is represented through the ",(0,a.kt)("inlineCode",{parentName:"p"},"compose")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"pipe")," functions. Both are implemented without the overloads, which causes the types to be rather ",(0,a.kt)("em",{parentName:"p"},"imposed")," than inferred."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import compose from 'fnts/compose';\n\nconst isTwoDigits = compose(\n  compose(\n    (b: boolean) => b ? 'true' : 'false',\n    (s: string) => s.length === 2 // argument type imposed from the next function\n  ),\n  (n: number) => `${n}`,\n); // will accept only a number as argument\n\nisTwoDigits(5) === 'false';\nisTwoDigits(14) === 'true';\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import pipe from 'fnts/pipe';\n\nconst isTwoDigits = pipe(\n  pipe(\n    (n: number) => `${n}`,\n    (s: string) => s.length === 2\n  ),\n  (b: boolean) => b ? 'true' : 'false',\n);\n\nisTwoDigits(5) === 'false';\nisTwoDigits(14) === 'true';\n")),(0,a.kt)("h3",{id:"currying"},(0,a.kt)("a",{parentName:"h3",href:"/concepts/currying"},"Currying")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"curry")," function is here to help with auto-currying of variadic or fixed amount of arguments."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import curry from 'fnts/curry';\n\nconst sumOfThree = curry(\n  (a: number, b: number, c: number): number => {\n    return a + b + c;\n  }\n);\n\nsumOfThree(1, 2, 3) === \nsumOfThree(1, 2)(3) === \nsumOfThree(1)(2, 3) === \nsumOfThree(1)(2)(3);\n")),(0,a.kt)("h3",{id:"application"},(0,a.kt)("a",{parentName:"h3",href:"/concepts/application"},"Application")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"apply")," function calls the functions provided to it on the same set of arguments\nand returns the tuple with results."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import apply from 'fnts/apply';\n\napply(\n    (a: number, b: number) => a + b,\n    (a: number, b: number) => a - b,\n    (a: number, b: number) => a / b,\n    (a: number, b: number) => a * b,\n)(3, 2); // [5, 1, 1.5, 6]\n")),(0,a.kt)("h3",{id:"arguments-permutation"},(0,a.kt)("a",{parentName:"h3",href:"/concepts/arguments-permutation"},"Arguments Permutation")),(0,a.kt)("p",null,"For non-commutative operations or functions that ",(0,a.kt)("em",{parentName:"p"},"can")," be applied in the compositional context it is handy to be able to automatically permutate (switch places of) their arguments. For some functions in ",(0,a.kt)("inlineCode",{parentName:"p"},"fnts")," this is already implemented:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { fmap } from 'fnts/maybe/operators';\n\nconst mapToNumber = (maybe: Maybe<string>): Maybe<number> => fmap(maybe, (value) => Number(value));\n")),(0,a.kt)("p",null,"Here, ",(0,a.kt)("inlineCode",{parentName:"p"},"mapToNumber")," declaration is equivalent to:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { fmap } from 'fnts/maybe/operators';\n\nconst mapToNumber = fmap<string, number>(Number);\n")),(0,a.kt)("h3",{id:"side-effects"},(0,a.kt)("a",{parentName:"h3",href:"/concepts/side-effects"},"Side effects")),(0,a.kt)("p",null,"For handling side effects there are a couple of functions, the underlying concept of which is to not interfere with the main execution flow:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import inject from 'fnts/inject';\n\nconst computeAndLog = inject(\n  compute,\n  (...args) => console.log('Computing with args: ', args)\n);\n\ncomputeAndLog(1, 2, 3);\n")),(0,a.kt)("h3",{id:"guarding"},(0,a.kt)("a",{parentName:"h3",href:"/concepts/guarding"},"Guarding")),(0,a.kt)("p",null,'In computing there\'s a pattern called "guard". Specifically, Haskell has a dedicated ',(0,a.kt)("a",{parentName:"p",href:"https://wiki.haskell.org/Pattern_guard"},"syntax")," for that, which ",(0,a.kt)("inlineCode",{parentName:"p"},"fnts")," also implemented in a more JavaScripty way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import guard from 'fnts/guard';\n\nguard<(x: number) => number>(\n  [(x) => x < 5, (x) => x + 1],\n  [(x) => x === 5, (x) => x - 1],\n  () => 1\n)(5) // 4\n")),(0,a.kt)("h3",{id:"lensing--ish"},"Lensing (-ish?)"),(0,a.kt)("p",null,"Functional lenses have not (and probably will not) yet seen its way into\n",(0,a.kt)("inlineCode",{parentName:"p"},"fnts"),", but for now there's one special ",(0,a.kt)("inlineCode",{parentName:"p"},"get")," function that knows how to\nsafely get a value from an object (even a nested one):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import get from 'fnts/get';\n\nget(\n  { a: { b: { c: 1 } } },\n  'a.b.c'\n);\n\nget('a.b.c.0.d')({ a: { b: { c: [{ d: 1 }] } } });\n")),(0,a.kt)("p",null,"Dot-notated path is always validated, although intellisense breaks at array\nindices and onward."),(0,a.kt)("hr",null),(0,a.kt)("p",null,"For a full overview of the available tools consult with the ",(0,a.kt)("a",{parentName:"p",href:"/api"},"API")," reference."))}m.isMDXComponent=!0}}]);